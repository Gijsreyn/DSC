use std::collections::HashMap;
use std::path::PathBuf;

use crate::config::subcontainer::{KeywordType, SubContainer, UpdateKind};
use crate::config::utils::{export_json, export_sshd_config, validate_config};
use crate::sshdconfig_error::SshdConfigError;

/// ConfigData is the top-level object that contains all information for sshd_config
pub struct ConfigData {
    pub config_lookup: HashMap<String, SubContainer>,
    config_filepath: PathBuf,
}

impl ConfigData {
    pub fn new() -> Self {
        let mut config_lookup = HashMap::new();
        // TODO: import const_keywords mod & use VALID_KEYWORDS to initialize config_lookup
        // TODO: config_filepath will be set by import_sshd_config
        Self {
            config_lookup,
            config_filepath: PathBuf::from("not implemented yet"),
        }
    }

    /// import_sshd_config will update config_lookup
    /// from a text file (sshd_config)
    pub fn import_sshd_config(&self, filepath: &PathBuf) -> Result<(), SshdConfigError> {
        // this could be done a few ways
        // call validate_config with the provided file
        // update config_lookup with output of validate_config
        // pass through the text file to mark any "non-default" values
        // explicitly set in the file that may look like "defaults"
        // call setter for self.config_filepath to store location of file
        Ok(())
    }

    /// import_json will update config_lookup from a json
    pub fn import_json(&self, data: &String) -> Result<(), SshdConfigError> {
        // TODO: think of more efficient way to validate json
        // run validate_config with empty file to initialize config_lookup
        // update config_lookup from json key-value pairs
        // mark any input values as "non-default" in config_lookup
        // export config_lookup to temp file to run validate_config
        // to confirm validity
        Ok(())
    }

    /// apply_config will be called from set
    /// needs to do the following:
    /// validate the updated config, export it
    /// to the filepath, and restart sshd (platform specific)
    fn apply_config(&self) -> Result<(), SshdConfigError> {
        Ok(())
    }

    /// backup_file will be called from set
    /// needs to backup original sshd_config
    /// if a backup does not already exist
    fn backup_file(&self) -> Result<(), SshdConfigError> {
        Ok(())
    }

    /// file_check will be called from import_sshd_config
    /// to check if the input file was generated by the tool
    /// if it was, compare hash and file contents
    /// to verify no external modifications were made
    fn file_check(&self) -> Result<(), SshdConfigError> {
        Ok(())
    }

    /// compare will be called from set & test
    /// return: hashmap with subcontainer values from self and hashmap with updateKind
    /// for any <keyword, values> that differ between self & config,
    /// the <keyword, updateKind> is needed for set, can be ignored for test
    fn compare(&self, config: &ConfigData) -> Result<(Option<HashMap<String, SubContainer>>, Option<HashMap<String, UpdateKind>>), SshdConfigError> {
        Ok((None, None))
    }

    /// update will be called from set
    /// it will call add/remove/modify accordingly
    fn update(&self, config: &HashMap<String, SubContainer>, update_kind: &HashMap<String, UpdateKind>) -> Result<(), SshdConfigError> {
        Ok(())
    }

    /// modify is intended to be called from set
    /// when a keyword that is already defined in ConfigData needs to be changed
    /// # Example
    /// cd = ConfigData::new();
    /// cd.modify("Port".to_string(), KeywordType::KeywordValue("1234".to_string()))
    fn modify(&mut self, keyword: &String, args: KeywordType) -> Result<(), SshdConfigError> {
        Ok(())
    }

    /// add is intended to be called from set
    /// when a keyword & its args are not already defined in ConfigData and need to be added
    /// # Example
    /// cd = ConfigData::new();
    /// cd.add("Port".to_string(), KeywordType::KeywordValue("1234".to_string()))
    fn add(&mut self, keyword: &String, args: KeywordType) -> Result<(), SshdConfigError> {
        Ok(())
    }

    /// remove is intended to be called from set
    /// when a keyword & its args are already defined in ConfigData but need to be removed
    /// # Example
    /// cd = ConfigData::new();
    /// cd.remove("Port".to_string(), KeywordType::KeywordValue("1234".to_string()))
    fn remove(&mut self, keyword: &String, args: KeywordType) -> Result<(), SshdConfigError> {
        Ok(())
    }
}

impl Default for ConfigData {
    fn default() -> Self {
        ConfigData::new()
    }
}

pub trait Invoke {
    fn get(&self, keywords: &Option<Vec<String>>) -> Result<String, SshdConfigError>; 
    fn set(&self, other: &ConfigData, purge: bool) -> Result<bool, SshdConfigError>;
    fn test(&self, other: &ConfigData) -> Result<(String, bool), SshdConfigError>;
}

impl Invoke for ConfigData {
    /// # Example
    /// cd = ConfigData::new();
    /// cd.import_sshd_config("PasswordAuthentication yes /r/n Port 1234")
    /// cd.get()
    /// returns {"PasswordAuthentication": "yes", "Port": 1234}
    /// cd.get(vec!["Port".to_string()])
    /// returns {"Port": 1234}
    fn get(&self, keywords: &Option<Vec<String>>) -> Result<String, SshdConfigError> {
        match self.file_check() {
            Ok(_) => {
                return export_json(&self.config_lookup, keywords)
            }
            Err(_) => { 
                return Err(SshdConfigError::NotImplemented)
            }
        }
    }
    /// # Example
    /// cd = ConfigData::new();
    /// cd.import_sshd_config("PasswordAuthentication yes") // existing config
    /// cd2 = ConfigData::new();
    /// cd2.import_sshd_config("PasswordAuthentication no") // input config
    /// cd.set(&cd2, false);
    /// expected outcomes: backup sshd_config if necessary, 
    /// update keyword(s) in sshd_config & restart sshd
    fn set(&self, other: &ConfigData, purge: bool) -> Result<bool, SshdConfigError> {
        let in_desired_state = false;
        // if purge is true, just replace self.config_lookup with other.config_lookup
        // else need to compare and update 
        match self.file_check() {
            Ok(_) => {
                let (diff, update_kind) = match other.compare(self) {
                    Ok(result) => (result.0, result.1),
                    Err(_) => { return Err(SshdConfigError::NotImplemented)} // TODO: handle error
                };
                match diff {
                    Some(diff) => {
                        match update_kind {
                            Some(update_kind) => {
                                match self.backup_file() {
                                    Ok(_) => {
                                        match self.update(&diff, &update_kind) {
                                            Ok(_) => {
                                                match self.apply_config() {
                                                    Ok(result) => { return Ok(in_desired_state) },
                                                    Err(_) => { return Err(SshdConfigError::NotImplemented)}
                                                }
                                            }
                                            Err(_) => { return Err(SshdConfigError::NotImplemented)}
                                        }
                                    },
                                    Err(_) => { return Err(SshdConfigError::NotImplemented)} //TODO: handle error
                                }
                            }
                            None => {
                                println!("failed to parse update kind");
                            }
                        }
                    } 
                    None => {
                        println!("{{}}");
                    }
                }
                Ok(in_desired_state)
            }
            Err(_) => {return Err(SshdConfigError::NotImplemented)}
        }
    }
    /// # Example
    /// cd = ConfigData::new();
    /// cd.import_sshd_config("PasswordAuthentication yes") // existing config
    /// cd2 = ConfigData::new();
    /// cd2.import_sshd_config("PasswordAuthentication no") // input config
    /// cd.test(&cd2);
    /// expected return: {"PasswordAuthentication": "yes"}
    fn test(&self, other: &ConfigData) -> Result<(String, bool), SshdConfigError> {
        let mut in_desired_state = false;
        let mut output;
        match self.file_check() {
            Ok(_) => {
                let (diff, _) = match self.compare(other) {
                    Ok(result) => (result.0, result.1),
                    Err(_) => { return Err(SshdConfigError::NotImplemented)} // TODO: handle error
                };
                match diff {
                    Some(diff) => {
                        match export_json(&diff, &None) {
                            Ok(result) => { output = result },
                            Err(_) => { return Err(SshdConfigError::NotImplemented)}
                        }
                    } 
                    None => {
                        output = "{}".to_string();
                        in_desired_state = true;
                    }
                }
                Ok((output, in_desired_state))
            },
            Err(_) => { return Err(SshdConfigError::NotImplemented)} // TODO: handle error
        }
    }
}
